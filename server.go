package main

import (
	"encoding/json"
	"flag"
	"html/template"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"time"
)

var (
	debug bool
	port  string
	revs  map[string]string
)

func main() {
	flag.StringVar(&port, "port", "3000", "application port")
	flag.BoolVar(&debug, "debug", false, "activate debug mode")
	flag.Parse()

	logger := log.New(os.Stdout, "", log.LstdFlags)
	if debug {
		logger.Println("Server is starting in debug mode...")
	} else {
		logger.Println("Server is starting...")
	}

	loadRevManifest(revs)

	router := http.NewServeMux()

	// Handles static files
	router.Handle("/static/", http.StripPrefix("/static/", http.FileServer(http.Dir("static"))))
	// Since the favicon.ico file is expected by browsers to be found at /favicon.ico, this special handler is needed.
	router.HandleFunc("/favicon.ico", favicon)
	router.HandleFunc("/", pages)

	server := &http.Server{
		Addr:         "0.0.0.0:" + port,
		Handler:      logging(router, logger),
		ErrorLog:     logger,
		ReadTimeout:  10 * time.Second,
		WriteTimeout: 10 * time.Second,
		IdleTimeout:  10 * time.Second,
	}

	logger.Println("Server is ready to handle requests on port", port)
	log.Fatal(server.ListenAndServe())
}

// Logging is a very simple logging middleware
func logging(h http.Handler, logger *log.Logger) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		logger.Println(r.RemoteAddr, "\""+r.Method, r.URL.Path, r.Proto+"\"")
		h.ServeHTTP(w, r)
	})
}

func favicon(w http.ResponseWriter, req *http.Request) {
	http.ServeFile(w, req, "./static/favicon.ico")
}

// Pages serves the HTML files located in the /templates folder
func pages(w http.ResponseWriter, req *http.Request) {
	lp := filepath.Join("templates", "layout.html")

	page := "index"

	if req.URL.Path != "/" {
		page = req.URL.Path
	}

	fp := filepath.Join("templates", page+".html")

	tmpl, err := template.New("tmpl").Funcs(template.FuncMap{
		"revving": revving,
	}).ParseFiles(lp, fp)

	if err != nil {
		// Log the detailed error
		log.Println(err.Error())
		// Return a generic "Internal Server Error" message
		http.Error(w, http.StatusText(500), 500)
		return
	}

	if err := tmpl.ExecuteTemplate(w, "layout", nil); err != nil {
		log.Println(err.Error())
		http.Error(w, http.StatusText(500), 500)
	}
}

// loadRevManifest loads the revision manifest generated by Gulp during the build process
func loadRevManifest(rev map[string]string) {
	file, err := ioutil.ReadFile("./static/assets/rev.json")

	if err != nil {
		log.Println("Failed to read rev file.")
	}

	err = json.Unmarshal(file, &rev)
	if err != nil {
		log.Println("Failed to unmarshal rev file.")
	}
}

// Revving provides a way to retrieve the name of the production-ready assets.
// It is meant to be used inside Go templates.
func revving(path string) string {
	if !debug {
		rev, found := revs[path]
		if found == true {
			return rev
		}
	}
	return path
}
